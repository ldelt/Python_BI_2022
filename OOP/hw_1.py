# -*- coding: utf-8 -*-
"""HW_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1duyXA-btTf7KsFWM2P6rgrBECtgK9pwq

# Задание 1 (5 баллов)

Напишите классы **Chat**, **Message** и **User**. Они должны соответствовать следующим требованиям:

**Chat**:
+ Должен иметь атрибут `chat_history`, где будут храниться все сообщения (`Message`) в обратном хронологическом порядке (сначала новые, затем старые)
+ Должен иметь метод `show_last_message`, выводящий на экран информацию о последнем сообщении
+ Должен иметь метод `get_history_from_time_period`, который принимает два опциональных аргумента (даты с которой и по какую мы ищем сообщения и выдаём их). Метод также должен возвращать объект типа `Chat`
+ Должен иметь метод `show_chat`, выводящий на экран все сообщения (каждое сообщение в таком же виде как и `show_last_message`, но с разделителем между ними)
+ Должен иметь метод `recieve`, который будет принимать сообщение и добавлять его в чат

**Message**:
+ Должен иметь три обязательных атрибута
    + `text` - текст сообщения
    + `datetime` - дата и время сообщения (встроенный модуль datetime вам в помощь). Важно! Это должна быть не дата создания сообщения, а дата его попадания в чат! 
    + `user` - информация о пользователе, который оставил сообщение (какой тип данных использовать здесь, разберётесь сами)
+ Должен иметь метод `show`, который печатает или возвращает информацию о сообщении с необходимой информацией (дата, время, юзер, текст)
+ Должен иметь метод `send`, который будет отправлять сообщение в чат

**User**:
+ Класс с информацией о юзере, наполнение для этого класса придумайте сами

Напишите несколько примеров использования кода, которое показывает взаимодействие между объектами.

В тексте задания намерено не указано, какие аргументы должны принимать методы, пускай вам в этом поможет здравый смысл)

В этом задании не стоит флексить всякими продвинутыми штуками, для этого есть последующие

В этом задании можно использовать только модуль `datetime`
"""

from datetime import datetime


class Chat:
    # Ваш код здесь
    
    def __init__(self):
        self.chat_history = []
    
    def _recieve(self, message):
        if isinstance(message, Message):
            self.chat_history.insert(0, message)
        else:
            print('This is not message')
          
    def _new_chat_from_mlist(self, chat_list):
        chat = type(self)()
        chat.chat_history = chat_list

        return chat

    def show_last_message(self):
        self.chat_history[0].show()
    
    def get_history_from_time_period(self, start=None, stop=None):
        datetime_start = datetime.strptime(start, '%d.%m.%Y %H:%M:%S') if start else None
        datetime_stop = datetime.strptime(stop, '%d.%m.%Y %H:%M:%S') if stop else None
        chat_slice = []

        for message in self.chat_history:
            if datetime_start is not None and message.datetime < datetime_start:
                continue
            if datetime_stop is not None and message.datetime > datetime_stop:
                continue
            chat_slice.append(message)

        return self._new_chat_from_mlist(chat_slice)

    def show_chat(self):
        for message in reversed(self.chat_history):
            message.show()
            print()

    

class Message:
    # Ваш код здесь

    def __init__(self, user, text):
        self.text = text
        self.datetime = None
        self.user = user

    def show(self):
        new_datetime = self.datetime.strftime('%d.%m.%Y %H:%M:%S')
        print(f'Date and time: {new_datetime}', 
              f'User: {self.user}; Hero: {self.user.hero}',
              f'Text: {self.text}', sep='\n')
    
    def send(self, chat_name):
        self.datetime = datetime.now()
        chat_name._recieve(self)



class User():
    # Ваш код здесь

    def __init__(self, nickname, hero):
        self.nickname = nickname
        self.hero = hero
        self.reg_date = datetime.now()
    
    def __repr__(self):
        return self.nickname

phoenix = User('Птичка', 'Phoenix')
venomancer = User('ffe', 'Venomancer')
slark = User('Madao', 'Slark')
lion = User('СМЕТАНА', 'Lion')

m1 = Message(phoenix, 'посоветуйте ониме новичку')
m2 = Message(venomancer, 'твое имя')
m3 = Message(slark, 'антон')
m4 = Message(lion, 'а?')
m5 = Message(lion, 'че звал сларк?')

chat = Chat()

m1.send(chat)
m2.send(chat)
m3.send(chat)
m4.send(chat)
m5.send(chat)

m1.show()

chat.show_last_message()

chat.show_chat()

sf = User('Kaneki Kek', 'Shadow Fiend')
Message(sf, 'Let me die').send(chat)
Message(sf, 'I don\'t really know what the point in life is').send(chat)
Message(sf, 'Everybody knows...').send(chat)

chat_history = chat.get_history_from_time_period(start='20.04.2023 22:30:51', 
                                                 stop='20.04.2025 22:30:00')
chat_history.show_chat()

"""# Задание 2 (3 балла)

В питоне как-то слишком типично и неинтересно происходят вызовы функций. Напишите класс `Args`, который будет хранить в себе аргументы, а функции можно будет вызывать при помощи следующего синтаксиса.

Использовать любые модули **нельзя**, да и вряд-ли это как-то поможет)
"""

class Args:

    def __init__(self, *args, **kwargs):
        self.args = args
        self.kwargs = kwargs

    def __rlshift__(self, other):
        result = other(*self.args, **self.kwargs)
        return result

sum << Args([1, 2])

(lambda a, b, c: a**2 + b + c) << Args(1, 2, c=50)

"""# Задание 3 (5 баллов)

Сделайте класс наследник `float`. Он должен вести себя как `float`, но также должен обладать некоторыми особенностями:
+ При получении атрибутов формата `<действие>_<число>` мы получаем результат такого действия над нашим числом
+ Создавать данные атрибуты в явном виде, очевидно, не стоит

Подсказка: если в процессе гуглёжки, вы выйдете на такую тему как **"Дескрипторы", то это НЕ то, что вам сейчас нужно**

Примеры использования ниже
"""

class StrangeFloat(float):
    def __getattr__(self, target):
        parts = target.split('_')

        if parts[0] == 'add':
            result = self + float(parts[1])
        elif parts[0] == 'subtract':
            result = self - float(parts[1])
        elif parts[0] == 'multiply':
            result = self * float(parts[1])
        elif parts[0] == 'divide':
            result = self / float(parts[1])

        return type(self)(result)

number = StrangeFloat(3.5)

number.add_1

number.subtract_20

number.multiply_5

number.divide_25

number.add_1.add_2.multiply_6.divide_8.subtract_9

getattr(number, "add_-2.5")   # Используем getattr, так как не можем написать number.add_-2.5 - это SyntaxError

number + 8   # Стандартные для float операции работают также

number.as_integer_ratio()   # Стандартные для float операции работают также  (это встроенный метод float, писать его НЕ НАДО)

"""# Задание 4 (3 балла)

В данном задании мы немного отдохнём и повеселимся. От вас требуется заменить в данном коде максимально возможное количество синтаксических конструкций на вызовы dunder методов, dunder атрибутов и dunder переменных.

Маленькая заметка: полностью всё заменить невозможно. Например, `function()` можно записать как `function.__call__()`, но при этом мы всё ещё не избавляемся от скобочек, так что можно делать так до бесконечности `function.__call__.__call__.__call__.__call__.....__call__()` и при всём при этом мы ещё не избавляемся от `.` для доступа к атрибутам. В общем, замените всё, что получится, не закапываясь в повторы, как в приведённом примере. Чем больше разных методов вы найдёте и используете, тем лучше и тем выше будет балл

Код по итогу дожен работать и печатать число **4420.0**, как в примере. Структуру кода менять нельзя, просто изменяем конструкции на синонимичные

И ещё маленькая подсказка. Заменить здесь можно всё кроме:
+ Конструкции `for ... in ...`:
+ Синтаксиса создания лямбда функции
+ Оператора присваивания `=`
+ Конструкции `if-else`
"""

import numpy as np


matrix = []
for idx in range(0, 100, 10):
    matrix += [list(range(idx, idx + 10))]
    
selected_columns_indices = list(filter(lambda x: x in range(1, 5, 2), range(len(matrix))))
selected_columns = map(lambda x: [x[col] for col in selected_columns_indices], matrix)

arr = np.array(list(selected_columns))

mask = arr[:, 1] % 3 == 0
new_arr = arr[mask]

product = new_arr @ new_arr.T

if (product[0] < 1000).all() and (product[2] > 1000).any():
    print(product.mean())

# Ваш код здесь

np = __import__('numpy')

matrix = []

for idx in range(0, 100, 10):
    matrix = matrix.__add__([list(range(idx, idx.__add__(10)))])

selected_columns_indices = list(filter(lambda x: range(1, 5, 2).__contains__(x), range(matrix.__len__())))
selected_columns = map(lambda x: [x.__getitem__(col) for col in selected_columns_indices], matrix)

arr = np.array(list(selected_columns))

mask = arr.__getitem__((slice(None, None, None), 1)).__mod__(3).__eq__(0)
new_arr = arr.__getitem__(mask)

product = new_arr.__matmul__(new_arr.transpose())

if (product.__getitem__(0).__lt__(1000)).all().__and__((product.__getitem__(2).__gt__(1000)).any()):
    print(product.mean())

"""# Задание 5 (10 баллов)

Напишите абстрактный класс `BiologicalSequence`, который задаёт следующий интерфейс:
+ Работа с функцией `len`
+ Возможность получать элементы по индексу и делать срезы последовательности (аналогично строкам)
+ Вывод на печать в удобном виде и возможность конвертации в строку
+ Возможность проверить алфавит последовательности на корректность

Напишите класс `NucleicAcidSequence`:
+ Данный класс реализует интерфейс `BiologicalSequence`
+ Данный класс имеет новый метод `complement`, возвращающий комплементарную последовательность
+ Данный класс имеет новый метод `gc_content`, возвращающий GC-состав (без разницы, в процентах или в долях)

Напишите классы наследники `NucleicAcidSequence`: `DNASequence` и `RNASequence`
+ `DNASequence` должен иметь метод `transcribe`, возвращающий транскрибированную РНК-последовательность
+ Данные классы не должны иметь <ins>публичных методов</ins> `complement` и метода для проверки алфавита, так как они уже должны быть реализованы в `NucleicAcidSequence`.

Напишите класс `AminoAcidSequence`:
+ Данный класс реализует интерфейс `BiologicalSequence`
+ Добавьте этому классу один любой метод, подходящий по смыслу к аминокислотной последовательности. Например, метод для нахождения изоэлектрической точки, молекулярного веса и т.д.

Комментарий по поводу метода `NucleicAcidSequence.complement`, так как я хочу, чтобы вы сделали его опредедённым образом:

При вызове `dna.complement()` или условного `dna.check_alphabet()` должны будут вызываться соответствующие методы из `NucleicAcidSequence`. При этом, данный метод должен обладать свойством полиморфизма, иначе говоря, внутри `complement` не надо делать условия а-ля `if seuqence_type == "DNA": return self.complement_dna()`, это крайне не гибко. Данный метод должен опираться на какой-то общий интерфейс между ДНК и РНК. Создание экземпляров `NucleicAcidSequence` не подразумевается, поэтому код `NucleicAcidSequence("ATGC").complement()` не обязан работать, а в идеале должен кидать исключение `NotImplementedError` при вызове от экземпляра `NucleicAcidSequence`

Вся сложность задания в том, чтобы правильно организовать код. Если у вас есть повторяющийся код в сестринских классах или родительском и дочернем, значит вы что-то делаете не так.


Маленькое замечание: По-хорошему, между классом `BiologicalSequence` и классами `NucleicAcidSequence` и `AminoAcidSequence`, ещё должен быть класс-прослойка, частично реализующий интерфейс `BiologicalSequence`, но его писать не обязательно, так как задание и так довольно большое (правда из-за этого у вас неминуемо возникнет повторяющийся код в классах `NucleicAcidSequence` и `AminoAcidSequence`)
"""

from abc import ABC, abstractmethod


# Ваш код здесь

class BiologicalSequence(ABC):

    @abstractmethod
    def __len__(self):
        pass

    @abstractmethod
    def __getitem__(self, slc):
        pass

    @abstractmethod
    def __repr__(self):
        pass
    
    @abstractmethod
    def check_alphabet(self):
        pass

class NucleicAcidSequence(BiologicalSequence):
    
    def __init__(self, seq):
        raise NotImplementedError("Создание экземпляров не поддерживается. Используйте классы DNASequence или RNASequence")
  
    def __len__(self):
        return len(self.seq)
    
    def __getitem__(self, slc):
        return self.seq[slc]
    
    def __repr__(self):
        return self.seq
    
    def check_alphabet(self):
        nucleotides = set(self.seq)
        if not nucleotides.issubset(self.alphabet):
            print('НЕкорректная последовательность')
        else:
            print('Последовательность корректна')
    
    def complement(self):
        compl_list = [self.complementarity_dictionary[nucl] for nucl in self.seq]
        complement_seq = ''.join(compl_list)
        return complement_seq

    def gc_content(self):
        gc_con = (self.seq.count('G') + self.seq.count('C')) / len(self.seq)
        return gc_con

class DNASequence(NucleicAcidSequence):

    def __init__(self, seq):
        self.seq = seq
        self.alphabet = {'A', 'T', 'G', 'C'}
        self.complementarity_dictionary = {'A':'T',
                                           'G':'C',
                                           'T':'A',
                                           'C':'G'}
    def transcribe(self):
        return self.seq.replace("T", "U")

class RNASequence(NucleicAcidSequence):

    def __init__(self, seq):
        self.seq = seq
        self.alphabet = {'A', 'U', 'G', 'C'}
        self.complementarity_dictionary = {'A':'U',
                                           'G':'C',
                                           'U':'A',
                                           'C':'G'}

class AminoAcidSequence(BiologicalSequence):
    def __init__(self, seq):
        self.seq = seq
        self.alphabet = {'A', 'C', 'D', 'E', 'F', 'G', 'I', 'H', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y'}

        #Словарь взял отсюда. 
        #https://stackoverflow.com/questions/27361877/how-i-can-add-the-molecular-weight-of-my-new-list-of-strings-using-a-mw-dictiona
        
        self.weights = {'A': 71.04, 'C': 103.01, 'D': 115.03, 'E': 129.04, 'F': 147.07,
                        'G': 57.02, 'H': 137.06, 'I': 113.08, 'K': 128.09, 'L': 113.08,
                        'M': 131.04, 'N': 114.04, 'P': 97.05, 'Q': 128.06, 'R': 156.10,
                        'S': 87.03, 'T': 101.05, 'V': 99.07, 'W': 186.08, 'Y': 163.06}
  
    def __len__(self):
        return len(self.seq)
    
    def __getitem__(self, slc):
        return self.seq[slc]
    
    def __repr__(self):
        return self.seq
    
    def check_alphabet(self):
        nucleotides = set(self.seq)
        if not nucleotides.issubset(self.alphabet):
            print('НЕкорректная последовательность')
        else:
            print('Последовательность корректна')
    
    def molecular_weight(self):
        weight = sum([self.weights[ac] for ac in self.seq])
        return weight

NucleicAcidSequence("ATGC").complement()

DNASequence("ATGCCC").check_alphabet()

DNASequence("ATGCCU").check_alphabet()

DNASequence("ATGCC").transcribe()

RNASequence("AUGC").complement()

RNASequence("AUGC")

str(RNASequence("AUGC"))

len(RNASequence("AUGC"))

RNASequence("AUGCGGGGG")[3:7]

AminoAcidSequence('ACDEF').molecular_weight()